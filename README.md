C - Sorting algorithms & Big O

Computer science sorting algorithms are significant and are used in many different applications. 
They are used to reorder a group of things or components into a predetermined order, like ascending 
or descending order. Time complexity, which depicts how the algorithm's running time increases as 
the amount of the input data (the number of elements to be sorted) grows, is a common metric used
to assess the effectiveness of sorting algorithms. Big O notation is a prominent tool for analyzing 
sorting algorithms.


#Bubble Sort:
When two adjacent components are in the wrong order, the bubble sort continuously steps through
the list, compares them, and swaps them out. 
Up until there are no more exchanges required, it goes on.

#Counting Sort and Radix Sort:
When sorting numbers with a small range, the non-comparative sorting algorithms counting sort
and radix sort perform extremely well.

#Heap Sort:
A partially ordered tree is maintained via heap sort using a binary heap data structure. 
It repeatedly takes the largest element out of the heap and puts it in the array's sorted section.

#Insertion Sort:
The final sorted array is constructed using insertion sort, one item at a time. Each item from
the input list is taken, and it is inserted into the sorted portion of the array at the proper place.

#Merge Sort:
A divide-and-conquer strategy known as merge sort separates the input list into smaller sublists, 
sorts those sublists, and then merges the sublists back together to create the sorted list.
In comparison to the earlier algorithms, it has a significantly lower average-case time complexity.


#Selection Sort:
The input list is split into two sections: one that is sorted and the other that is not. 
The minimal (or maximum) element from the unsorted section is repeatedly chosen and
transferred to the sorted part.


#Quick Sort:
Another divide-and-conquer technique is quick sort, which chooses an element to act as a "pivot" 
and divides the array into two subarrays: one with elements smaller than the pivot and the other
with elements larger than the pivot. After that, it sorts the subarrays iteratively.

